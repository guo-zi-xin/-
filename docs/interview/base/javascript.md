# JavaScript 相关

### JavaScript 中的基本数据类型

[前端数据类型](../../native/javascript/前端数据类型)

### Ajax使用

Ajax（Asynchronous JavaScript and XML）是一种使用 JavaScript 和 XML 进行异步通信的技术。它可以在不刷新整个页面的情况下，通过向服务器发送请求并获取响应数据，实现动态更新页面内容。

一个完整的AJAX请求包括以下步骤：

- 创建 `XMLHttpRequest` 对象：在 JavaScript 中，使用 `XMLHttpRequest` 对象来发起 Ajax 请求。可以通过 `new XMLHttpRequest()` 来创建该对象。
- 设置回调函数：在发送请求之前，需要设置一个回调函数来处理服务器响应。可以通过 `onreadystatechange` 属性来监听状态变化，并在状态变化时触发回调函数。
- 打开和发送请求：使用 `open()` 方法来指定请求的类型（GET 或 POST）以及请求的 URL。然后使用 `send()` 方法发送请求
- 处理响应：在回调函数中，可以通过 `readyState` 属性判断请求的状态，并通过 `status` 属性判断服务器响应的状态码。当 `readyState` 等于 *4* 并且 `status` 等于 *200* 时，
  表示请求成功，并可以通过 `responseText` 或 `responseXML` 属性获取服务器返回的数据。

- 示例

```javascript
  var xhr = new XMLHttpRequest();
  xhr.onreadystatechange = function() {
    if (xhr.readyState === 4 && xhr.status === 200) {
      var response = xhr.responseText;
      // 处理服务器返回的数据
      console.log(response);
    }
  };
  xhr.open('GET', 'http://example.com/api/data', true);
  xhr.send();
```

### 闭包

##### 闭包的定义

闭包可以简单理解成：定义在一个函数内部的函数， 其中一个内部函数在包含他们的外部函数之外被调用时，就会形成闭包

##### 闭包的特性

- 闭包的写法一般是函数嵌套函数

- 可以访问函数外部的变量：闭包可以访问定义它的函数的参数和局部变量，甚至可以访问全局变量。

- 保存变量的状态：当函数执行完毕后，闭包仍然可以访问它所引用的变量，并且这些变量的值不会被回收。

- 可以作为参数传递：闭包可以作为参数传递给其他函数，也可以被其他函数返回。

**优点**

- 变量长期驻扎在内存中
- 避免全局变量的污染
- 存在私有成员

**缺点**

- 会造成内存泄漏

::: details 什么是内存泄漏
  内存泄漏(Memory Leak)是指程序中已经不再使用的内存没有被及时释放，导致系统的可用内存逐渐减少，最终可能导致程序崩溃。

  **产生场景**

  - *对象或变量未被正确销毁*：当一个对象或变量不再被使用时，应该及时将它们从内存中删除。如果没有正确销毁这些对象或变量，它们所占用的内存就会一直存在，造成内存泄漏。

  - *循环引用*：当两个或多个对象相互引用时，如果它们之间没有被正确断开引用关系，就会形成循环引用。这种情况下，这些对象所占用的内存就无法被垃圾回收器回收，从而导致内存泄漏。

  - *定时器未被清除*：在使用 JavaScript 定时器时，如果没有及时清除已经失效的定时器，就会导致定时器所占用的内存无法被释放，从而造成内存泄漏。

  - *闭包*

  - *脱离DOM的引用*
  
  **防止内存泄漏**

  1. 及时销毁不再使用的对象或变量，尤其是大内存占用的对象。

  2. 避免循环引用，确保对象之间的引用关系能够正确断开。

  3. 在使用定时器时，一定要记得及时清除已经失效的定时器。

  4. 使用内存分析工具来检测内存泄漏问题，及时发现和解决潜在问题。
:::

### 事件委托

事件委托就是利用时间冒泡，只制定一个时间处理程序，就可以管理某一些类型的所有事件。

                                                                —— JS高级程序设计

事件委托，称为事件代理，是js中很常用的绑定事件的技巧，事件委托就是把原本需要绑定在子元素上的响应时间委托给父元素，让父元素担当事件监听的职务，事件委托的原理就是DOM元素的时间冒泡

##### 事件委托优点

- **提高整体运行性能**

  假如现在有有00个li标签，那个li事件都有相同的点击事件，如果使用循环遍历去触发每个li元素上的事件， 这将会不断与DOM节点进行交互，访问DOM次数越多，引起浏览器回流和重绘的次数也就越多，
  就会延长整个页面的交互时间，如果委托给父级ul标签， 我们与DOM的交互只需要交互一次，这样就大大减少DOM的交互次数， 提高性能

- **减少内存空间**
  
  每个函数都是对象，对象会占用内存，对象越多，内存占用率越大，性能也会变差，但利用事件委托，就只对它的父级进行操作，减少了调用的对象，节省了内存空间

- **动态绑定事件处理程序**
  
  由于事件委托是基于事件冒泡机制实现的，因此可以动态地添加或删除子元素，而无需重新绑定事件处理程序。

- **处理未来元素的事件**

  由于事件委托是基于父元素的事件处理程序实现的，因此可以处理未来添加到页面上的元素的事件

```javascript
  window.onload = function() {
      var oUl = document.getElementById('ul1')
      oUl.onclick = function() {
        alert('利用事件冒泡的原理，将事件委托给父元素')
      }
  }
```

##### 事件源

Event 对象提供了一个属性叫 `target`， 可以返回事件的目标节点，我们称为事件源。

但这个有兼容性：

> 标准浏览器使用 `event.target` IE浏览器使用 `event.srcElement`

### 事件冒泡

当一个元素接收到事件的时候，会把接收到事件传递给自己的父级。这种传递分为三个阶段

- 捕获阶段：从window对象传导到目标节点(从外向里)， 这个阶段不会响应任何时间
- 目标阶段：从目标节点触发
- 冒泡阶段：从目标节点传回到window对象(从里到外), 事件委托/代理就是利用事件冒泡的机制把里层需要相拥的事件绑定到外层

### 本地存储与cookie的区别

本地存储(Local Storage)和Cookie都是用于在浏览器端存储数据的两种不同的机制，主要有以下区别

- 存储容量

  Cookie的存储容量通常比较小，每个cookie的大小限制为4KB， 因为每个http请求都会携带cookie，如果过多的cookie数据，会影响请求性能

  本地存储的容量相对较大，通常可达到5MB，这使得本地存储更适合大量数据的本地保存

- 生命周期
  
  Cookie可以设置过期时间，可以使会话级的(浏览器关闭时失效)， 也可以是持久性的。Cookie还可以设置域名和路径，用于控制其在哪些请求中发送

  本地存储分为两种 `localStorage`和`sessionStorage`. `localStorage`是永久性的，除非通过代码或者浏览器设置进行删除，而`sessionStorage`存储的数据会在会话结束时失效，
  即浏览器标签关闭

- 安全性
  
  Cookie存在一些安全性问题，因为他可以被跨站脚本(XSS)攻击，也可能被窃取

  本地存储相对来说更安全，因为它不会随着HTTP请求被发送到服务器，减少了被窃取的风险，但仍然需要注意防范XSS攻击

- 用途
  
  Cookie主要用户客户端与服务端传递信息，可以在请求头中携带Cookie

  本地存储主要用户客户端本地保存数据，供同一域名下的页面之间共享

- 访问方式
  
  Cookie 通过`document.Cookie`来进行访问和设置

  本地存储通过`localSorage`和`sessionStorage`对象进行访问与设置

  38页/第9题
