# 2024-03-20 字节面试

## 关于Vue组件通信

常用的组件通信方式有以下几种

  - **props**

  - **$emit**

  - **ref 和 defineExpose**

  - **provide 和 inject**

  - **v-model**

  - **pinia**

  - **mitt**

- ### props

<div style="color:#89DDFF;margin:10px 0">父组件将数据传给子组件，子组件通过props属性接收父组件传递的数据</div>

- 子组件 Child.vue:

```vue
<script setup>
/**
 * 使用 defineProps 函数来定义 Props 的类型和默认值
 * defineProps 不需要引入就可以直接使用
*/

const props = defineProps({
  // 变量 count 是通过父组件传递过来的
  count: {
    type: Number,
    default: 0
  }
})
</script>
```

上段代码中， 使用`defineProps`函数来定义props的类型和默认值。

  1. 在 `defineProps`的参数中，我们可以定义一个对象，其中的每个属性代表一个Prop
  2. 在这个示例中， 我们定义了一个名为 count 的 prop， 它的类型是 Number，并设置了默认值为0
  3. 之后在`<template>`中, 可以直接使用 count 变量，他是通过父组件传递过来的

- 父组件 Parent.vue

```vue
<script setup>
// 引入 ref 函数， 用于定义响应式数据
import { ref } from 'vue';
// 引入子组件 Child.vue
import Child from './Child.vue'

//使用 ref 函数创建一个响应式变量count， 初始值为0， 该变量将用于传递给子组件
let count = ref<number>(0)
</script>

<template>
  <div id="parent">
    <!-- 将 count 变量传递给子组件 Child -->
    <Child :count="count"/>
  </div>
</template>
```

上面代码中：

  1. 我们使用了 ref 函数创建了一个响应式变量count，初始值为0，该变量1将用于传递给子组件。
  2. 然后再template中， 通过`:count="count"`的方式将count变量传递给子组件`Child`

通过 props， 就实现了一个最简单的父组件到子组件的数据传递

- ###  $Emit

<div style="color:#89DDFF;margin:10px 0">子组件通过$emit方法触发一个自定义事件，并传递给需要的参数。父组件通过在子组件上监听对应的时间，并指定触发事件时的回调函数</div>

**子组件 Child.vue**

```vue
<script setup>
/**
 * 使用 defineProps 函数来定义 Props 的类型和默认值
 * defineProps 不需要引入即可直接使用
 */

  const props = defineProps({
    // 变量 count 是通过父组件传递过来的
    count: {
      type: Number,
      default: 0
    }
  })

  // 使用 defineEmits 函数定义了一个名为 changeParentCount 的自定义事件
  const emit = defineEmits(['changeParentCount'])
  const changeParentCount = () => {
    // 通过 emit 方法触发名为 changeParentCount 的自定义事件，并将参数 5 传递给父组件
    emit('changeParentCount', 5)
  }
</script>

<template>
  <div id="child">
    <h1>count: {{ count }}</h1>
    <button @click="changeParentCount">更新父组件的count</button>
  </div>
</template>
```

上段代码中：

  1. 我们在`<template>`的 button中使用 @click="changeParentCount" 添加点击事件监听器，当按钮被点击时，将调用 changeParentCount 方法，触发父组件中的自定义事件

  2. 然后使用 defineEmits函数定义了一个名为 changeParentCount的自定义事件。然后通过 emit方法触发名为 changeParentCount 的自定义事件， 并将参数 5 传递给父组件

**父组件 Parent.vue**

```vue
<script setup>
// 引入 ref 函数， 用于定义响应式数据
import { ref } from 'vue';
// 引入子组件 Child.vue
import Child from './Child.vue'

// 使用 ref 函数创建了一个响应式变量count， 初始值为0，该变量用于传递给子组件
let count = ref<number>(0)

// 这个方法用于处理子组件中触发的自定义事件 changeParentCount 并更新父组件中 count 变量的值
const changeParentCount = (params: number):void => {
  count.value += params
}
</script>

<template>
  <div id="parent">
    <!-- 将 count 变量传递给子组件 Child  -->
    <!-- 监听子组件自定义事件 changeParentCount -->
    <Child :count="count" @changeParentCount="changeParentCount"/>
  </div>
</template>
```

上面这段代码中：

  - 在template中， 我们通过@符号监听子组件自定义事件changeParentCount 并在父组件中执行名为changeParentCount的方法。它接收一个params的参数，然后更新父组件中count变量的值

- ###  ref 和 defineExpose

<div style="color:#89DDFF;margin:10px 0">
  在Vue3中， ref函数除了可以用于定义一个响应式的变量或引用之外，还可以获取DOM组件实例。
</div>

<div style="color:#89DDFF;margin:10px 0">而 defineExpose适用于将组建内部的属性和方法暴露给父组件或者其他组件使用。通过这种方式，我们可以定义哪些部分可以从组件外部访问和调用。</div>

**子组件Child.vue**

```vue
<script setup>
  // 引入 ref 函数，用于定义响应式数据
  import { ref } from 'vue';

  // 定义变量和方法
  const msg = ref<string>('我是子组件中的数据');
  const childMethod = ():void => {
    console.log('我是子组件中的方法');
  }

  // defineExpose 对外暴露组件内部的属性和方法，不需要引入，直接使用
  // 将属性 msg 和方法 childMethod 暴露给父组件
  defineExpose({ msg, childMethod })
</script>

```

上面这段代码中

  1. 我们定义了一个 msg 变量和一个childMethod的方法。
  
  2. 然后使用 defineExpose函数将msg和childMethod对外暴露出去

这样， 我们在父组件中就可以访问子组件的msg属性或者调用 childMethod 方法

**父组件Parent.vue**

```vue
<script setup>
  // 引入响应式ref
  import { ref } from 'vue';
  // 引入子组件 Child.vue
  import Child from './Child.vue';

  // 获取子组件DOM实例
  const childRef = ref(null);

  // 该方法用于获取子组件对外暴露的属性和方法
  const getChildPropertyAndMethod = () => {
    // 获取子组件对外暴露的属性
    console.log(childRef.value.msg);
    // 调用子组件对外暴露的方法
    childRef.value.childMethod();
  }
</script>

<template>
  <div id="parent">
    <Child ref="childRef"/>
    <button @click="getChildPropertyAndMethod">获取子组件对外暴露的属性和方法</button>
  </div>
</template>
```

上段代码中

  1. 我们在 template子组件Child身上绑定了一个ref，然后通过`const childRef = ref(null)` 来获取子组件的DOM实例

  2. 然后给button绑定了一个点击事件 getChildPropertyAndMethod，该方法用于获取子组件对外暴露的属性和方法

  3. 此时，点击按钮，在控制台中可以看到打印出子组件的数据和方法的结果

总结：这种方式之间的通信，主要是在子组件内部，将属性和方法暴露出去，然后再子组件中，先获取到子组件的DOM实例，然后就可以访问子组件的属性和调用子组件的方法了。

- ### provide 和 inject 

  - <div style="color:#89DDFF;margin:10px 0">provide是在父组件中定义的方法，用于提供数据给子组件</div> 它接受两个参数，第一个参数是一个字符串或者一个Symbol类型的键，用于识别提供的数据。第二个参数是要提供的数据本身。
  这个数据可以是响应式的对象、响应式的ref、reactive对象、函数等。父组件中使用provide提供数据后，所有的子组件都可以通过inject来访问这些数据。

  - <div style="color:#89DDFF;margin:10px 0">inject时在子组件中使用的方法，勇于接受父组件提供的数据。</div>它接收一个参数，即要注入的数据的键。
  在子组件中使用inject时，可以直接使用接收到的数据，而不需要再组件的配置选项中声明这些数据。

**父组件Parent.vue**

```vue
<script setup>
/**
 * 引入 ref 函数，用于定义响应式数据
 * 引入 provide，用于提供数据给所有子组件
 */
import { ref, provide } from 'vue'
// 引入子组件1和子组件2
import Child1 from './Child1.vue'
import Child2 from './Child2.vue'

// 定义一个 message 响应式数据
  const message = ref<string>('我是父组件的数据')

  //使用provide 将数据message注入， 并且提供给所有子组件
  provide('message', message)
</script>

<template>
  <div id="parent">
    <Child1/>
    <Child2/>
  </div>
</template>
```

**子组件Child1.vue**

```vue
<script setup>
import { inject } from 'vue'
//使用inject 获取来自父组件的数据 message
const parentMessage = inject('message')

<template>
  <div id="child">
    <p>子组件1: {{ parentMessage }}</p>
  </div>
</template>
</script>
```

**子组件Child2.vue**

```vue
<script setup>
import { inject } from 'vue'
//使用inject 获取来自父组件的数据 message
const parentMessage = inject('message')

<template>
  <div id="child">
    <p>子组件2: {{ parentMessage }}</p>
  </div>
</template>
</script>
```

上面的代码中：

  1. 我们在父组件 Parent.vue 中定义了一个响应式数据 message

  2. 然后使用 provide 将数据 message 提供给所有子组件

  3. 在子组件 Child1 和 Child2 中，我们使用 inject 获取来自父组件的数据
  message。

  4. 此时，在页面中，我们可以看到子组件获取到的父组件数据。

**除了获取数据，我们也可以修改数据：**

```vue
<script setup>
  import { inject } from 'vue';

  // 使用 inject 获取来自父组件的数据 message
  const parentMessage = inject('message');

  // 该方法用于更改父组件的message
  const changeParentMessage = () => {
    parentMessage.value = '我更改了message值'
  }
</script>

<template>
  <div id="child">
    <p>子组件1: {{ parentMessage }}</p>
    <button @click="changeParentMessage">更改父组件message</button>
  </div>
</template>

```

上面这段代码中：

1. 在子组件 Child1 中，我们定义了一个 changeParentMessage 函数，它更新了来自父组件的 message 值。

2. 由于 message 在父组件中是响应式的，所以更新后该值将自动反映在父组件的视图中。

3. 此时，我们点击一下按钮，子组件1和子组件2的值都会被更改。

总结：过使用 provide 和 inject，数据能够在父组件和子组件之间进行传递和共享，实现了跨组件的通信。

- ### v-model

<div style="color:#89DDFF;margin:10px 0">
  v-model可以同事支持多个数据双向绑定。
</div>

**子组件Child.vue**

```vue
<script setup>
const emit = defineEmits(['update:name', 'update:age'])

const changeParentMsg = () => {
  emit('update:name','Steven')
  emit('update:age', 36)
}
</script>

<template>
  <div id="Child">
    <button @click="changeParentMsg">更新父组件中的name和age</button>
  </div>
</template>
```

**父组件Parent.vue**

```vue
<script setup>
  // 引入 ref 函数，用于定义响应式数据
  import { ref } from 'vue';
  // 引入子组件
  import Child from './Child.vue';

  // 定义两个响应式的变量
  let name = ref<string>('Echo');
  let age = ref<number>(26);
</script>

<template>
  <div id="parent">
    <p>父组件Name：{{ name }}</p>
    <p>父组件Age： {{ age }}</p>
    <!-- 使用 v-model 将父组件的 name 和 age 双向绑定到子组件的 name 和 age 上 -->
    <Child v-model:name="name" v-model:age="age"/>
  </div>
</template>
```

面的代码中：

  1. 我们在父组件内部使用 ref 函数定义了两个响应式变量 name 和 age，并给它们分别赋予初始值。然后在 template 中使用 v-model 将父组件的 name 和 age 双向绑定到子组件的 name 和 age 上。

  2. 在子组件内部，通过 defineEmits(['name', 'age'])，我们定义了两个事件：update:name 和 update:age。这样，父组件可以监听并处理这两个事件。然后我们
  在 template 中定义了一个按钮，并在 script 中实现 changeParentMsg 的方法。当按钮被点击时，这个方法会调用 emit 方法来派发两个事件。

  3. 通过 emit('update:name', 'Steven')，我们触发了一个名为 update:name 的事件，并传递了一个参数 'Steven'。通过这个事件，我们可以告知父组件更新它的 name 值为 'Steven'。

  4. 通过 emit('update:age', 36)，我们触发了一个名为 update:age 的事件，并传递了一个参数 36。通过这个事件，我们可以告知父组件更新它的 age 值为 36。

通过这样的设置，当父组件中的 name 或 age 发生变化时，它们会自动更新到子组件中。同时，当子组件中的 name 或 age 改变时，它们会通过 update:name 和
update:age 事件反馈给父组件，父组件会相应地更新自己的 name 和 age。这就实现了父子组件之间的双向绑定。

- ### mitt

在Vue3中，可以使用第三方库mitt来实现组件之间的通信。
<div style="color:#89DDFF;margin:10px 0">mitt是一个简单且强大的事件总线库(类似于Vue2中的 EventBus), 它提供了一种方便的方式来在不同组件中传递事件和数据。</div>

首先 安装 mitt.js

```shell
npm install mitt
#     or
yarn install mitt
#     or
pnpm install mitt
```

接着，创建一个event bus

```ts
import mitt from 'mitt'
const bus = mitt()
export default bus
```

在需要通信的组件中，导入 event bus 对象并进行事件的监听和触发:

**组件First.vue**

```vue
<script setup>
  import mitt from './mitt'

  const emitEvent = () => {
    mitt.emit('updateName', 36)
  }
</script>

<template>
  <div id="first">
    <button @click="emitEvent">更新name和age</button>
  </div>
</template>
```

**组件Second.vue**

```vue
<script setup>
  import mitt from '../mitt';
  import { ref } from 'vue';

  let name = ref('Echo');
  let age = ref(26);

  mitt.on('updateName', (data) => {
    name.value = 'Steven';
    age.value = data;
  });
</script>

<template>
  <div id="second">
    <p>name: {{ name }}</p>
    <p>age: {{ age }}</p>
  </div>
</template>
```

上面这个例子中：

  1. 我们创建了一个名为 mitt 的事件总线对象，并在两个组件中进行了引用。
  
  2. 在 First 组件中，当按钮被点击后，我们使用 mitt.emit 方法触发了一个自定义事件，并传递了一些数据。
  
  3. 在 Second 组件中，我们使用 mitt.on 方法监听了 updateName 事件，并在回调函数中接收到了传递的数据。然后我们将接收到的数据赋值给相应的属性，在模板中展示出来。

通过这种方式，我们可以在不同的组件中实现通信，First 组件可以通过事件总线发送事件和数据，Second 组件则监听事件并接收到数据进行处理。

- ### Pinia

  pinia 是一个为 vue3 设计的状态管理库，类似 Vuex 的设计模式，通过定义 store、状态、getter 和 action，来统一管理应用程序的状态和逻辑。

## React中遇到过什么坑

## SSR中Node的配置消耗的QPS

## React的生命周期

## 常用的React Hook 和功能

## 什么是虚拟滚动

## lightHouse主要使用什么性能指标

## 跨页面通信使用什么方式呢

## 跨域的方法

## 通过iframe标签跨页面通信遇到过什么问题

登录状态不一致

还有iframe的宽高设置， 第三方页面的滚动

△ 微前端的方式

## 有了解过mono-repo开发方式吗

## UseMemo可以在其他地方调用么

## 项目中做了哪些性能优化

## 构建工具有什么性能优化

## 基本数据类型

## 在项目中有自己实现过Hook吗，举个例子说明
