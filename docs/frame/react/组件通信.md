# React 组件间的通信

### 父组件调用子组件

⾯试指南 1
⾯试指南
React基础使⽤及⼋股⽂
⽗组件调⽤⼦组件⽅法
使⽤useImperativeHandle调⽤⼦组件⽅法。

```javascript
import { useImperativeHandle, useRef, useState } from 'react
/**
 * ⼦组件
 */
const ChildrenComponent = (props: any) => {
const [count, setCount] = useState(0);
 useImperativeHandle(props.childrenRef, ()=>({
 handleClick: () => setCount(c => c+1),
 handleDelete: () =>setCount(c =>c > 0 ? c-1 : 0),
 }))
 return (
 <div>count {count}</div>
 )
}
/**
 * ⽗组件
 */
function App() {
 const childrenRef = useRef();
 return (
 <>
 <div onClick = {() => childrenRef.current.handleClick()}>

⾯试指南 2
 <div onClick = {() => childrenRef.current.handleDelete()}
 <ChildrenComponent childrenRef = {childrenRef}/>
 </>
 )
}

export default App
```

### React和Vue的区别

1. vue是双向数据绑定react是单向数据流
2. 在vue中我们组合不同功能的⽅式是通过mixin，⽽react中我们通过HoC
3. React是JSX渲染模板 vue是通过拓展HTML语法进⾏渲染。
React设计思想

-  组件化
每个组件都符合开放-封闭原则，封闭是针对渲染⼯作流来说，指的是组件内部的状
态都由⾃⾝维护，只处理内部渲染逻辑，开放是针对组件通信来说，指的是不同组件
可以通过props(单向数据流)进⾏数据交互。
-  数据驱动视图
UI=(data)
渲染界⾯不应该直接操作dom⽽是通过修改数据state或props，数据驱动视图更新。
-  虚拟DOM
由浏览器的渲染流⽔线可知DOM操作是⼀个昂贵的操作很耗费性能所以就有了虚拟
DOM，虚拟DOM是对真实DOM的映射，React通过新旧dom对⽐得到需要更新的部
分实现数据的增量更新。
React⽣命周期
分为组件挂载阶段、组件更新阶段、组件卸载阶段

-  挂载
constructor
⾯试指南 3
componentWillMount
render
componentDidMount
-  更新
componentWillReceiveProps
shouldComponentUpdate
componentWillUpdate
render
componentWillUnmount
-  卸载
componentWillUnmount
React严格模式
识别不安全声明周期
关于使⽤过时字符串ref api警告
关于使⽤废弃的findDOMNode
检测意外的副作⽤
React中遍历⽅法
遍历数组：map && forEach
遍历对象： map && for in
在React中⻚⾯重新加载时怎么保留数据
这个问题就涉及到了数据持久化，主要有以下⼏种实现⽅式：
Redux： 将⻚⾯数据储存在Redux中，在重新加载⻚⾯时获取Redux中的数据。
data.js: 使⽤webpack构建的项⽬，可以建⼀个⽂件，data.js将数据保存在data中
跳转⻚⾯后获取
sessionStorge：存⼊sessionStorge初始化时查询有数据就加载⽆数据就是初始
化状态。
⾯试指南 4
history API： 使⽤ pushState 函数可⽀持临时储存。
zustand: 轻量级状态管理包 不到1kb
什么是jsx与js的区别
JSX是react的语法糖，它允许在html中写js不能被浏览器直接识别需要通过
webpack、babel之类的编译⼯具转换为hs执⾏。
JS可以被打包⼯具直接编译不需要额外的转换，JSX需要babel编译转换为浏览
器识别的语⾔。
jsx是js的语法扩展允许在html中写js，js是原⽣写法需要通过script标签引⼊
React必须⽤jsx吗
不强制使⽤jsx。当不想在构建环境中配置有关jsx编译时，不在react中使⽤jsx会更加
⽅便，每个jsx元素只是调⽤React.createElement(component,props,...children)的语
法糖。因此使⽤JSX可以完成的任何事情都可以通过纯js完成。
useffect和 useLayoutEffect 区别
useEffect 是异步执⾏的，⽽ useLayoutEffect 是同步执⾏的。
useEffect 的执⾏时机是浏览器完成渲染之后，⽽ useLayoutEffect 的执⾏时机是
浏览器把内容真正渲染到界⾯之前，和 componentDidMount 等价。
React处理错误边界
受控组件、⾮受控组件
受控组件就是改变受控于数据的变化，数据变了⻚⾯也变了。受控组件更合适，
数据驱动是react核⼼。
⾮受控组件不是通过数据控制⻚⾯
SSR的理解
对SEO友好
爬⾍获取到的是已经异步执⾏完 有数据的html
所有的模板、图⽚资源都存在服务器端
⼀个html返回所有数据
减少HTTP请求
⾯试指南 5
响应快、⽤户体验好、⾸屏渲染快
⾸屏的渲染是node发送过来的html字符串，并不依赖于js⽂件了，这就会使
⽤户更快的看到⻚⾯的内容。尤其是针对⼤型单⻚应⽤，打包后⽂件体积⽐
较⼤，普通客户端渲染加载所有所需⽂件时间较⻓，⾸⻚就会有⼀个很⻓的
⽩屏等待时间。
SSR的局限：

- 服务端压⼒⼤：正常是通过客户端去渲染，现在统⼀到服务端node去做。尤其是
⾼并发访问的情况，会⼤量占⽤服务端CPU资源。

- 开发条件受限：在服务端渲染中只会执⾏到componentDidMount之前的⽣命周
期,因此有些第三⽅库会受到影响.
为什么虚拟DOM会提⾼性能
虚拟DOM相当于是js和真实DOM中间加了⼀个缓存，利⽤DOM Diff算法避免了没有
必要的DOM操作，从⽽提⾼性能。
💡 吃透虚拟DOM和Diff算法
结构对⽐
React.createElement 和 document.createElement
虚拟DOM是⼀个对象，⽽真实DOM是dom结构(断点看到真实dom中挂载了很多属性
和⽅法 我们并不需要去关⼼这些属性和⽅法 都是默认的因为标准是这么设计的)所以
从结构上虚拟DOM⽐真实DOM轻很多
流程对⽐
传统web应⽤，数据的变化会实时地更新到⽤户界⾯中于是每次数据微⼩的变化都会
引起DOM渲染。
在虚拟DOM中 是将所有操作聚集在⼀块计算出所有变化后统⼀更新⼀次虚拟DOM
虚拟DOM是什么？

<div className='Index'>
 <div>我是⼩杜杜</div>
⾯试指南 6
 <ul>
 <li>React</li>
 <li>Vue</li>
 </ul>
 </div>
转化后
{
type: 'div',
props: {class: 'Index'},
children: [
{
type: 'div',
children: '我是⼩杜杜'
 },
{
type: 'ul',
children: [
{
type: 'li',
children: 'React',
},
{
type: 'li',
children: 'Vue',
}
]
}
]
}
type 实际的标签
props 标签内部的属性(除key和ref，会形成单独的key名)
⾯试指南 7
children 为节点内容依次循环
React组件为什么要⼤写？
因为jsx语法⽆法被浏览器识别需要使⽤Babel去转换为浏览器识别的js，此时就会有
个依据去判断是原⽣DOM标签还是React组件，这个依据就是标签的⾸字⺟
如果标签的⾸字⺟⼩写的话就会被认为是原⽣标签，反之就是React组件
React.Fragment
React中组件是不允许返回多个节点的要想解决这个问题就需要套⼀层div但是这样会
多增加⼀个节点所以在`16.0`后官⽅推出了Fragment碎⽚概念，能够让⼀个组件返回
多个元素`React.Fragment 等价于 `<></>`
React.Fragment和<></>的区别，上⾯说到key和ref是单独存放的 区别就是
React.Fragment可以使⽤key⽽空标签不可以
虚拟DOM优势所在
提⾼效率不⽤关注DOM只关注业务逻辑。
性能提升(牢记浏览器在处理DOM时很慢处理js会很快)且虚拟DOM感受到变化的时候
会局部更新⽽⾮整体，从⽽减少⾮常多的DOM操作所以性能会提⽰。
⛔ 虚拟DOM的优势其实是在于它的diff算法和批量处理策略 将所有DOM搜集
起来 ⼀起去改变真实的DOM 但在⾸次渲染上，虚拟DOM会多了⼀层计
算，消耗⼀些性能，所以有可能会⽐html慢。虚拟DOM只是规划⼀个最短
路 但是还得是真实dom去⾛
超强的兼容性
具有浏览器的兼容和跨平台的兼容
⾯试指南 8
React基于虚拟DOM实现了⼀套⾃⼰的事件机制 并且模拟了时间冒泡和捕获的过
程采取事件代理批量更等⽅法从⽽磨平各个浏览器事件兼容性问题
对于跨平台React和React Native都是根据虚拟dom画出相应平台的UI层 只不过
不同的平台画法不⼀样
useCallback说明例⼦
跳过组件的重新渲染
从记忆化回调中更新 state
防⽌频繁触发 Effect
优化⾃定义 Hook
//跳过组件的重新渲染
const handleSubmit = useCallback((orderDetails) => {
 post('/product/' + productId + '/buy', {
 referrer,
 orderDetails,
 });
 }, [productId, referrer]);
// 从记忆化回调中更新 state. 有时，你可能在记忆化回调中基于之前的 stat
const handleAddTodo = useCallback((text) => {
 const newTodo = { id: nextId++, text };
 setTodos(todos => [...todos, newTodo]);
 }, []);
// 防⽌频繁触发 Effect
const createOptions = useCallback(() => {
 return {
 serverUrl: 'https://localhost:1234',
 roomId: roomId
 };
 }, [roomId]); // ✅ 仅当 roomId 更改时更改
 useEffect(() => {
⾯试指南 9
 const options = createOptions();
 const connection = createConnection();
 connection.connect();
 return () => connection.disconnect();
 }, [createOptions]); // ✅ 仅当 createOptions 更改时更改
// 优化⾃定义 Hook
function useRouter() {
 const { dispatch } = useContext(RouterStateContext);
 const navigate = useCallback((url) => {
 dispatch({ type: 'navigate', url });
 }, [dispatch]);
 const goBack = useCallback(() => {
 dispatch({ type: 'back' });
 }, [dispatch]);
 return {
 navigate,
 goBack,
 };
}
useMemo
在初次渲染时，你从 useMemo 得到的 值 将会是你的 calculation 函数执⾏的结果。
在随后的每⼀次渲染中，React 将会⽐较前后两次渲染中的 所有依赖项 是否相同。
如果通过 Object.is ⽐较所有依赖项都没有发⽣变化，那么 useMemo 将会返回之前已
经计算过的那个值。否则，React 将会重新执⾏ calculation 函数并且返回⼀个新的
值。
换⾔之， useMemo 在多次重新渲染中缓存了 calculation 函数计算的结果直到依赖项的
值发⽣变化。
跳过代价昂贵的重新计算
跳过组件的重新渲染
⾯试指南 10
记忆另⼀个 Hook 的依赖
记忆⼀个函数
Hooks与class区别
1. 更简洁
2. 业务代码更加聚合
3. 逻辑⽅便复⽤
⾼阶函数HOC
在 React 中，⾼阶组件（HOC）是⼀个接收组件作为参数并返回⼀个新组件的函
数。换句话说，它是⼀种组件的转换器。⾼阶组件通常⽤于在组件之间复⽤逻辑，例
如状态管理、数据获取、访问控制等。
HOC 的⼀个常⻅⽰例是 React-Redux 的 connect 函数，它将 Redux store 连接到
React 组件，使组件可以访问和更新 store 中的状态
⾼阶组件是 React 中⼀种强⼤的模式，可以帮助我们在组件间复⽤逻辑、修改
props、实现条件渲染以及提供额外的功能。通过熟练掌握⾼阶组件的概念和使⽤⽅
法，我们可以提⾼代码的可维护性和可读性，构建更加健壮、⾼效的应⽤程序。在实
际项⽬中，我们可能会遇到各种⾼阶组件的应⽤场景，因此掌握⾼阶组件的使⽤⽅法
对于 React 开发者来说⾄关重要。
useState和useRef的区别
⽤于管理状态和操作dom。
两者之间最⼤的区别是 useState ⽤于管理状态，⽽ useRef ⽤于操作 DOM 元素。另
外，useState 返回的是当前状态和⼀个更新状态的函数，⽽ useRef 返回的是⼀个全
局可以访问和修改的 Ref 对象。useState ⽤于保存和更新组件的状态，⽽ useRef ⽤
于引⽤ DOM 元素或者保存值。useState 的值会被重新渲染，⽽ useRef 的值不会。
1. useState的值在每个rernder中都是独⽴存在的，⽽useRef.current则更像是相对
于render函数的⼀个全局变量，每次他会保持render的最新状态。（useState异
步更新其值，useRef同步更新）
⾯试指南 11
2. useState触发重新渲染，useRef不触发。
3. useRef() 不仅⽤于DOM引⽤。“ ref”对象是通⽤容器，其当前属性是可变的，并
且可以保存任何值，类似于类的实例属性。
4. 变量是决定视图图层渲染的变量，请使⽤useState，其他⽤途useRef
5. useRef特性：可变的ref对象，持久化。
useContext
组件嵌套不⽤⼀层⼀层props传参，可以直接实现A组件传值到C组件 创建⽅法为
createContext
⽗组件与⼦组件加载顺序
⽗⼦组件初始化
⽗组件 constructor
⽗组件 getDerivedStateFromProps
⽗组件 render
⼦组件 constructor
⼦组件 getDerivedStateFromProps
⼦组件 render
⼦组件 componentDidMount
⽗组件 componentDidMount
⼦组件修改⾃⾝state
⼦组件 getDerivedStateFromProps
⼦组件 shouldComponentUpdate
⼦组件 render
⼦组件 getSnapShotBeforeUpdate
⼦组件 componentDidUpdate
⽗组件修改props
⽗组件 getDerivedStateFromProps
⽗组件 shouldComponentUpdate
⾯试指南 12
⽗组件 render
⼦组件 getDerivedStateFromProps
⼦组件 shouldComponentUpdate
⼦组件 render
⼦组件 getSnapShotBeforeUpdate
⽗组件 getSnapShotBeforeUpdate
⼦组件 componentDidUpdate
⽗组件 componentDidUpdate
卸载⼦组件
⽗组件 getDerivedStateFromProps
⽗组件 shouldComponentUpdate
⽗组件 render
⽗组件 getSnapShotBeforeUpdate
⼦组件 componentWillUnmount
⽗组件 componentDidUpdate
