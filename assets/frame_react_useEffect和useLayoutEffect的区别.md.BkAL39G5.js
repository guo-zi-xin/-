import{_ as a}from"./chunks/PageInfo.vue_vue_type_script_setup_true_lang.QrrBmjNq.js";import{_ as c,c as f,j as t,a as s,G as u,a6 as r,o as d}from"./chunks/framework.8Xbk4tT3.js";import"./chunks/theme.VasyDUoe.js";const L=JSON.parse('{"title":"useEffect和useLayoutEffect的区别","description":"","frontmatter":{},"headers":[],"relativePath":"frame/react/useEffect和useLayoutEffect的区别.md","filePath":"frame/react/useEffect和useLayoutEffect的区别.md","lastUpdated":1731650204000}'),l={name:"frame/react/useEffect和useLayoutEffect的区别.md"};function i(n,e,E,m,p,h){const o=a;return d(),f("div",null,[e[0]||(e[0]=t("h1",{id:"useeffect和uselayouteffect的区别",tabindex:"-1"},[s("useEffect和useLayoutEffect的区别 "),t("a",{class:"header-anchor",href:"#useeffect和uselayouteffect的区别","aria-label":'Permalink to "useEffect和useLayoutEffect的区别"'},"​")],-1)),u(o,{readTime:"1",words:"484"}),e[1]||(e[1]=r('<ul><li><p><code>useEffect</code>: 执行时机是在React的渲染和提交阶段之后，这意味着当任何相关DOM更改被应用并且组件已经被重新渲染后，<code>useEffect</code>里的代码会执行。但它是异步的，所以可能会在浏览器的下一个绘制周期之后才会执行。</p></li><li><p><code>useLayoutEffect</code>: 执行时机是在React的提交阶段之后，但在浏览器实际绘制屏幕之前。这使得你可以同步的读取或更改DOM，然后让浏览器在下一次绘制时立即体现这些更改，从而避免不必要的闪烁或布局跳动。</p></li></ul><h2 id="何时使用useeffect" tabindex="-1">何时使用<code>useEffect</code> <a class="header-anchor" href="#何时使用useeffect" aria-label="Permalink to &quot;何时使用`useEffect`&quot;">​</a></h2><ul><li><strong>副作用与DOM无关</strong>: 例如数据获取、配置订阅，手动更改浏览器的URL等等。</li><li><strong>不需要立即同步读取或更改DOM</strong>: 如果不关心可能的微小布局跳动或闪烁，那么使用<code>useEffect</code>足够了</li><li><strong>性能考虑</strong> <code>useEffect</code>通常对性能影响较少，因为他不会阻塞浏览器渲染</li></ul><h2 id="何时使用uselayouteffect" tabindex="-1">何时使用<code>useLayoutEffect</code> <a class="header-anchor" href="#何时使用uselayouteffect" aria-label="Permalink to &quot;何时使用`useLayoutEffect`&quot;">​</a></h2><ul><li><strong>需要同步读取或更改DOM</strong>: 例如 读取元素的大小或位置 并在渲染前进行调整。</li><li><strong>防止闪烁</strong>: 在某些情况下，异步的<code>useEffect</code>可能会导致可见的布局跳动或闪烁。例如动画的启动或某些可见的快速DOM更改。</li><li><strong>模拟生命周期方法</strong>: 如果正在将旧的类组件迁移到功能组件，并需要模拟<code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>componentWillUnmount</code>的同步行为</li></ul><h2 id="使用注意事项" tabindex="-1">使用注意事项 <a class="header-anchor" href="#使用注意事项" aria-label="Permalink to &quot;使用注意事项&quot;">​</a></h2><ul><li>避免过度使用<code>useLayoutEffect</code>,因为它是同步的，可能会影响应用的性能。只有当确实需要同步操作DOM的时候才会使用它</li><li>如果代码在服务器端渲染(SSR)中出现问题，考虑回退到<code>useEffect</code>. <code>在服务器端渲染时不会运行，可能会引发警告或错误</code></li></ul>',7))])}const D=c(l,[["render",i]]);export{L as __pageData,D as default};
