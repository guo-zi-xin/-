import{_ as t}from"./chunks/PageInfo.vue_vue_type_script_setup_true_lang.ahzV38-K.js";import{_ as o,c as s,j as a,a as n,G as i,a6 as l,o as d}from"./chunks/framework.D7D3iUXQ.js";import"./chunks/theme._-NuN2Vt.js";const P=JSON.parse('{"title":"SSR相关","description":"","frontmatter":{},"headers":[],"relativePath":"frame/react/SSR相关.md","filePath":"frame/react/SSR相关.md","lastUpdated":1708859917000}'),p={name:"frame/react/SSR相关.md"};function c(S,e,m,f,h,_){const r=t;return d(),s("div",null,[e[0]||(e[0]=a("h1",{id:"ssr相关",tabindex:"-1"},[n("SSR相关 "),a("a",{class:"header-anchor",href:"#ssr相关","aria-label":'Permalink to "SSR相关"'},"​")],-1)),i(r,{readTime:"1",words:"273"}),e[1]||(e[1]=l('<h3 id="对于ssr的理解" tabindex="-1">对于SSR的理解 <a class="header-anchor" href="#对于ssr的理解" aria-label="Permalink to &quot;对于SSR的理解&quot;">​</a></h3><ul><li><p><strong>对SEO友好</strong></p><p>爬虫获取到的是已经异步执行完成后得到的有数据的HTML</p></li><li><p><strong>所有模板、图片资源都存储在服务器端</strong></p></li><li><p><strong>一个HTML 返回所有数据</strong></p></li><li><p><strong>减少HTTP请求</strong></p></li><li><p><strong>响应快、用户体验好、首屏渲染快</strong></p><p>首屏渲染是Node发送过来的字符串， 并不依赖与js文件了， 这就会使用户更快地看到页面的内容。 尤其是针对大型单页应用， 打包后文件体积比较大， 普通客户端渲染加载所有所需文件的时间较长， 首页就会有一个很长的加载时间。</p></li></ul><h3 id="ssr的局限" tabindex="-1">SSR的局限 <a class="header-anchor" href="#ssr的局限" aria-label="Permalink to &quot;SSR的局限&quot;">​</a></h3><ol><li>服务端压力大: 正常是通过客户端去渲染、现在统一到服务端Node去做。 尤其是遇到高并发访问的情况， 会大量占用服务端CPU资源</li><li>开发条件受限: 在服务端渲染中只会执行到<code>componentDidMount</code>之前的生命周期， 因此有些第三方库会受到影响。</li></ol>',4))])}const x=o(p,[["render",c]]);export{P as __pageData,x as default};
